# 5. Стурктурные типы данных

**Массивы (array)** - структурированный тип данных, являющиейся просто упорядоченой последовательностью других типов данных. В `php`, в отличие от многих других языков, есть всего один вид массивов, совмещающий в себе свойства разных структурных типов данных других языков.

## Создание массивов

Массив чисел без указания индексов или ключей:

```php
$my_array = array(1, 2, 3, 4, 5);
print_r($my_array);

/*Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
*/

// Начиная с PHP 5.4
$array = [1, 2];
```
Массив строк без указания индексов или ключей:

```php
$cars = ['BMW', 'Opel', 'Audi'];
print_r($cars);

/*Array
(
    [0] => BMW
    [1] => Opel
    [2] => Audi
)*/
```
Массив чисел с использованием строкового индекса:

```php
$marks = [
	'Pupkin' => 5,
	'Markov' => 2,
	'Kichev' => 4,
];
print_r($marks);

*/Array
(
    [Pupkin] => 5
    [Markov] => 2
    [Kichev] => 4
)
/*

```

## Операции с массивом

Получение элемента массива, добавление элемента массива:

```php
//добавление элемента в массив
$arr = [1, 2, 3];
$arr[] = 4;
print_r($arr);
/*Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
)
*/

//Получение элемента массива
echo $arr[2]; // выведет 3
```
Двумерный массив и получение вложенного элемента:

```php
$arr = ['z', 'x', ['aa', 'bb']];
print_r($arr);
echo PHP_EOL . $arr[2][0] . PHP_EOL;

/*Array
(
    [0] => z
    [1] => x
    [2] => Array
        (
            [0] => aa
            [1] => bb
        )
)
aa
*/

```
Удаление элемента массива:

```php
$arr = ['x', 'y', 'z', ['aa', 'bb'], '11'];
print_r($arr);
/*Array
(
    [0] => x
    [1] => y
    [2] => z
    [3] => Array
        (
            [0] => aa
            [1] => bb
        )
    [4] => 11
)*/
unset($arr[3]);
print_r($arr);
/*Array
(
    [0] => x
    [1] => y
    [2] => z
    [4] => 11
)*/
```

Удаление массива осуществляется функцией `unset`, примененной к переменной массива.


## Функции для работы с массивами

* `unset` - удаляет массив или элемент массива
* `array_values` - возвращает все значения массива в виде массива
* `array_keys` - возвращает все ключи массива в виде массива
* `array_map` - применяет функцию, имя которой идет первым параметром в кавычках, ко всем элементам массива

Существует огромное количество функций по работе с массивами, ознакомиться с ними можно [здесь ](http://php.net/manual/ru/ref.array.php) или в Google.


## Строки

Строка в php является простейшим массивом символов. К примеру, если в переменную `$S` записана строка `"Welcome"`, то `$S[3]` будет указывать на символ c.

Строки можно определять как одинарными, так и двойными кавычками. Строки в одинарных кавычках считаются немного более быстрыми в работе. Строки же в двойных кавычках позволяют выводить некоторые [escape-последовательности](http://php.net/manual/ru/regexp.reference.escape.php) и значения переменных, что уже упоминалось в первом уроке.


## Операторы цикла
Существуют следующие операторы цикла:

* while
* do while
* for
* foreach

В большинстве случаев операторы цикла взаимозаменяемы, но у каждого из них есть некоторые ньюансы.

## Оператор while

Простейший оператор цикла while выглядит так:
`while (условие) действие`
или
`while (условие) {блок действий в несколько строк}`

В прошлых уроках у нас уже были примеры циклов while.

Суть работы цикла: Проверяется условие в цикле, если оно вполняется (т.е. `true`), тело цикла выполняется. Затем опять проверяется условие цикла, если true - выполняется тело, и так до тех пор, пока не перестанет выполняться условие цикла.

```php
$i = 10;
while ($i > 0) {
    echo $i-- . PHP_EOL;
}
```

## Оператор do while 

Практически тот же цикл while, за одним уточнением: цикл всегда выполняется хотя-бы один раз перед проверкой условия. 

`do (тело цикла) while (условие)`

Тот же код но с циклом `do while`:

```php
$i = 10;
do {
    echo $i-- . PHP_EOL;
} while ($i > 0);
```

## Вечный цикл

В программировании довольно часто используются вечные циклы. Просто есть ситуации, когда нет явного ограничения, и условие трудно проверить заранее. Для того, чтобы выйти из вечного цикла, и вообще из цикла, используется оператор `break`. Он работает внутри цикла и прекращает его выполнение. Далее проиллюстрирована работа break и еще пары операторов:

```php
$i = 10;
while (true) {
    if ($i % 2 != 0)
        echo $i . PHP_EOL;
    $i--;
    if ($i % 20 > -19) continue;
    if ($i < -10) break;
}
```

## Цикл for

Цикл `for` представляет собой совмещение трех действий и цикла. В скобках до первой точки с запятой указывается начальное условие или условия, между первой и второй точкой с запятой указывается условие, которое надо проверять перед каждой итерацией цикла, а после второй точки с запятой - действия, который нужно проделать каждый цикл:

```php
$limit = 10;
for ($i=1; $i < $limit + 1; $i++) { 
        echo $i . PHP_EOL;
}
```

Цикл **for** во многом идентичен циклу **while**, если посмотреть на него под определенным углом зрения. По-сути, он так же, как и **while**, проверяет определенное условие, и при его соблюдении запускает очередную итерацию. Что добавляется, так это инициализация переменных до первой итерации (начальные условия) и обязательные каждую итерацию действия. Таким образом, **while** может заменить **for**, а **for** может заменить **while**. Это мы изучим на практике.


## Цикл foreach

Цикл `foreach` представляет собой наиболее удобный способ работы  массивами в `php`. В скобках указывается имя массива, затем, после ключевого слова `as` - пара переменных, разделенных знаком `=>`, первая переменная для ключа массива, вторая - для значения в массиве по этому ключу. Первая переменная не обязательна. Пример:

```php
$a = range(1, 10);
foreach ($a as $key => $value) {
    echo $value . PHP_EOL;
}
```

Также имеется сокращенный вариант цикла `foreach`, применяемый в случае, когда нам не нужны ключи и интересуют нас только значения массива:

```php
$a = range(1, 10);
foreach ($a as $value) {
    echo $value . PHP_EOL;
}
```


## Константы

Если в программе необходимо использовать какое-то число или строку, и программист знает, что эта строка или число не будут меняться в течении времени работы программы, лучше всего использовать константу.

```php
define("LOOP_LIMIT", 10);
define("LOOP_START", 1);
define("MESSAGE", 'Finish!');

$a = range(LOOP_START, LOOP_LIMIT);
foreach ($a as $key => $value) {
    echo $value . PHP_EOL;
}
echo MESSAGE;
```




## Домашка

[Домашнее задание](hw5.md)
